<!-- Generated by SpecStory -->

# Исправление подсветки синтаксиса в проекте (2025-08-12 05:54Z)

_**User**_

давйа исправим то, что может стать причиной потери подсветки в этой проекте
```
<#@ alias "index" #>
<#@ extend 'template.nhtml' #>

<section>
#{partial(context, 'panel')}
</section>
<section>
<# var extra = { title: 'Another panel!!!', body:'extra content'} #>
#{partial(extra, 'panel')}
</section>

```
Основываясь на предоставленном вами скриншоте и коде, я проанализировал потенциальные причины частичной потери подсветки синтаксиса.

На скриншоте видно, что директивы (`<#@ alias`, `<#@ extend>`), HTML-теги (`<section>`) и вызовы хелперов (`#{partial(...)}`) подсвечиваются, но код внутри блока `<# ... #>` — `var extra = { ... }` — отображается как обычный текст, за исключением ключевого слова `var`.

Это указывает на то, что проблема кроется не в полной неработоспособности расширения, а в конкретном правиле, которое отвечает за обработку общих блоков кода JavaScript.

Вот наиболее вероятные причины этой проблемы, от наиболее к наименее вероятной:

---

### 1. Наиболее вероятная причина: Ошибка в регулярном выражении TextMate

Основная подсветка синтаксиса в VS Code выполняется с помощью грамматик TextMate (файлы `.tmLanguage.json`), которые основаны на регулярных выражениях. Ваш языковой сервер (LSP) затем добавляет *семантические* токены для более точной подсветки (например, выделяет `partial` как функцию).

Проблема почти наверняка заключается в файле грамматики, который отвечает за `.nhtml` файлы: `syntaxes/template-html.tmLanguage.json`.

**Анализ:**

В этом файле есть правило, предназначенное для распознавания блоков с JS-кодом:

```json
{
  "begin": "(?:<#-(?!\\s*(?:block|slot)\\b)|<#(?!\\s*(?:block|slot|@|end\\s*#>)|\\{))",
  "end": "[-]?#>",
  "contentName": "meta.embedded.block.javascript",
  "patterns": [
    {
      "include": "source.js" // <--- Эта строка отвечает за подсветку JS
    },
    {
      "name": "support.function.fte",
      "match": "\\b(partial|content|slot|chunkStart|chunkEnd)\\s*(?=\\()"
    }
  ]
}
```

**Что здесь происходит:**

1.  **`"begin"`**: Это очень сложное регулярное выражение с **негативным просмотром вперед (negative lookahead)**.
    *   Оно пытается найти открывающий тег `<#` или `<#-`.
    *   При этом оно **исключает** случаи, когда за `<#` следуют `block`, `slot`, `@`, `end #>` или `{`.
    *   Цель этого — отделить обычные блоки кода от структурных элементов (блоков, директив и т.д.).

2.  **`"include": "source.js"`**: Эта строка — самая важная. Она говорит: "Если `begin`-выражение совпало, то всё, что находится внутри этого блока, должно быть подсвечено как JavaScript".

**Почему подсветка пропадает:**

Скорее всего, сложное `begin`-выражение **не срабатывает** для строки `<# var extra = ... #>`. Хотя логически оно должно сработать, любая мелкая ошибка в таком сложном регулярном выражении может привести к тому, что оно не найдет совпадения. Если совпадения нет, то правило `"include": "source.js"` никогда не выполняется, и текст остается без подсветки.

Подсветка `var` может происходить из-за другого, более общего правила, которое распознает это слово как ключевое, но не весь остальной синтаксис JS.

---

### 2. Недостаточный анализ со стороны языкового сервера (LSP)

Ваш языковой сервер в `server/src/semanticTokens.ts` отвечает за *семантическую* подсветку. Давайте посмотрим, что он делает для блоков кода:

```typescript
// server/src/semanticTokens.ts

// ...
case 'code': {
  // Recognize helper function names as functions
  const c = String(node.content || '')
  const helpers = ['partial', 'content', 'slot', 'chunkStart', 'chunkEnd']
  for (const h of helpers) {
    const re = new RegExp(String.raw`\b${h}\b`, 'g')
    // ... логика поиска и подсветки хелперов
  }
  break
}
```

**Анализ:**

Сервер в блоке `code` ищет **только** известные ему хелперы (`partial`, `content` и т.д.) и подсвечивает их как функции. Он **не выполняет** полный синтаксический анализ JavaScript, чтобы найти `var`, `{}` и другие элементы.

Это нормальная практика — LSP полагается на базовую TextMate-грамматику для общей подсветки, а сам лишь уточняет детали. Это подтверждает, что корень проблемы именно в TextMate-грамматике.

---

### 3. Конфликт правил или порядок их применения

В файлах `.tmLanguage.json` порядок правил имеет значение. Возможно, что какое-то другое, более общее правило (например, из `text.html.basic`, которое включается в `template-html.tmLanguage.json`) перехватывает строку `<# var ... #>` и помечает ее как обычный текст до того, как сработает ваше специальное правило для блоков кода. Это менее вероятно, но возможно.

---

### Рекомендации по исправлению

1.  **Используйте инструмент отладки VS Code.**
    *   Откройте ваш шаблонный файл.
    *   Вызовите палитру команд (Ctrl+Shift+P).
    *   Найдите и выполните команду **`Developer: Inspect Editor Tokens and Scopes`**.
    *   Наведите курсор на проблемный участок кода (`extra = { ... }`). Вы увидите, какое правило TextMate применяется к этому тексту и почему он не подсвечивается как `source.js`. Это самый точный способ диагностики.

2.  **Упростите регулярное выражение в грамматике.**
    Сложные негативные просмотры — частый источник ошибок. Попробуйте изменить структуру правил в `template-html.tmLanguage.json`. Вместо одного сложного правила для кода используйте несколько более простых, расположив их в правильном порядке:

    ```json
    // В repository.template-expressions.patterns
    
    // 1. Сначала идут самые специфичные правила (директивы, блоки)
    {
        "begin": "<#@\\s*", ...
    },
    {
        "begin": "<#\\s*-?\\s*(block|slot)\\s+...", ...
    },
    {
        "begin": "<#\\s*-?\\s*end\\s*-?\\s*#>", ...
    },
    // и т.д.

    // 2. В самом конце разместите простое "всеядное" правило для кода
    {
        "begin": "<#-?", // Простое совпадение
        "beginCaptures": { "0": { "name": "punctuation.definition.bracket.template.block.begin" } },
        "end": "-?#>",
        "endCaptures": { "0": { "name": "punctuation.definition.bracket.template.block.end" } },
        "contentName": "meta.embedded.block.javascript",
        "patterns": [
            { "include": "source.js" }
        ]
    }
    ```
    Поскольку TextMate проверяет правила по порядку, это простое правило сработает только для тех случаев, которые не были перехвачены более специфичными правилами выше. Это гораздо надежнее, чем одно сложное выражение.

### Заключение

Основная причина потери подсветки — **ошибка или излишняя сложность регулярного выражения** в `syntaxes/template-html.tmLanguage.json`, которое должно было распознавать блок кода и включать для него подсветку JavaScript (`source.js`). Отладка с помощью `Inspect Editor Tokens and Scopes` и упрощение этого выражения должны решить проблему.

---

_**Assistant**_

<think><details><summary>Thought Process</summary>**Addressing syntax highlighting issues**

I need to address problems in the repo related to syntax highlighting, as noted in the screenshot. The workspace rules say to utilize `server/src/parser.ts` for formatting and highlighting, and I must record bugs in `BUGS.md` and prioritize important tasks in `MUST_HAVE.md`. The user’s request translates to fixing potential causes of highlighting loss. I’ll need to investigate the rules in `template-html.tmLanguage.json`. Following the guidelines, I’ll do a broad codebase search first.
**Exploring semantic tokens implementation**

The implementation of `semanticTokens` in `server/src/semanticTokens.ts` is important. It seems this project acts as a VS Code language package for syntax highlighting within FTE templates. I plan to review the grammar file to understand the rules better. I'll make minimal changes to include `source.js` for the generic `<# ... #>` JS code block, run tests using Vitest, and check for lint errors. It looks like adding grammar tests might be tricky, but I could explore existing smoke tests for `semanticTokens` in the test directory.
**Testing semantic tokens functionality**

The LSP is located in `server/src`, and I can create a test in `server/__tests__/semanticTokens.test.ts` or `.js`. This test should confirm that input sample tokens include functions for 'partial,' maybe variables or punctuation. However, since the LSP highlights only helper functions and not JS tokens, I can’t test JS tokenization that way. Instead, I should check if the parser recognizes code blocks. I also need to ensure that the fallback highlighting is effective, even if the grammar fails. After reviewing, I’ll update `BUGS.md` with any found issues.
**Organizing the tasks ahead**

I need to create a checklist for tasks that includes fixing details and ensuring tests are in place. After implementing the grammar changes, I’ll run tests using Bun. Even though the grammar isn't specifically tested, I want to confirm that nothing has broken during the updates. There’s a chance everything will go smoothly, so let’s get started and make sure I’m following all steps carefully!</details></think>

---

Провожу быстрый обзор кода и правил грамматики для подсветки, чтобы найти и исправить потенциальную причину пропажи подсветки внутри `<# ... #>` блоков. Затем внесу правку в грамматику и запущу тесты.

---

<details>
                <summary>Searched codebase "Где в грамматике TextMate описаны блоки кода <# ... #> и подключение source.js для подсветки?" • **5** results</summary>
            
| File | Lines |
|------|-------|
| `syntaxes/template-html.tmLanguage.json` | L65-129 |
| `syntaxes/template-html.tmLanguage.json` | Lundefined-70 |
| `syntaxes/template-html.tmLanguage.json` | L215-282 |
| `syntaxes/template-html.tmLanguage.json` | L167-220 |
| `syntaxes/template-html.tmLanguage.json` | L124-170 |

</details>

---

Read file: undefined

---

Read file: undefined

---

Read file: undefined

---



---

