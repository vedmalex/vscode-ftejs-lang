# Техническая Спецификация: Рефакторинг Форматировщика и Исправление Багов

## 1. Обзор и Цели

Данный документ описывает требования к полному рефакторингу модуля форматирования и исправлению связанных критических багов. Цель — достичь стабильного, корректного и предсказуемого форматирования `fte.js` шаблонов, соответствующего требованиям `MUST_HAVE.md`.

## 2. Основные Принципы Рефакторинга

Новый алгоритм должен строго следовать этим принципам:

*   **Принцип 1: Сохранение Исходной Структуры.** Вместо полной реконструкции документа из AST, новый подход должен использовать исходный текст как основу и применять форматирование только к **конкретным сегментам**, идентифицированным парсером. Это исключит потерю данных и искажение структуры.
*   **Принцип 2: Четкое Разделение Ответственности.** Алгоритм должен четко разделять **"текст шаблона"** (то, что идет в вывод — HTML, JS, dotenv) и **"инструкции шаблонизатора"** (`<# ... #>`). Каждый тип должен форматироваться по своим правилам.
*   **Принцип 3: Prettier как Основной Инструмент.** Prettier должен использоваться как для текста шаблона, так и для кода инструкций, с соответствующими конфигурациями для каждого.

## 3. Спецификация: Рефакторинг Форматировщика

Необходимо полностью заменить текущую логику `formatSegments` в `server/src/formatterCore.ts` на новый, более надежный алгоритм.

### 3.1. Новый Алгоритм Форматирования

Новый алгоритм должен работать следующим образом:

1.  **Входные данные:** Принимает `ast` от `LocalParser` и оригинальный `text` документа.
2.  **Основа:** Использует `ast.tokens` — плоский список токенов в том порядке, в котором они идут в документе.
3.  **Итерация по токенам:** Алгоритм должен итерировать по `ast.tokens` и строить итоговый документ по частям.

#### 3.1.1. Обработка Текстовых Сегментов (HTML, Markdown, и т.д.)

*   **Задача:** Исправить "схлопывание" HTML и потерю переносов строк.
*   **Логика:**
    1.  Несколько идущих подряд токенов типа `text` и `expression` (`#{...}`) должны быть сгруппированы в один "текстовый чанк".
    2.  Этот чанк передается в `prettier.format()` с конфигурацией для целевого языка (см. п. 3.2).
    3.  Результат форматирования добавляется в итоговый документ.
    *   **Критически важно:** `#{...}` и `!{...}` должны рассматриваться как неотъемлемая часть текстового чанка, чтобы Prettier мог корректно отформатировать их в контексте окружающего HTML/JS.

#### 3.1.2. Обработка Сегментов Инструкций (`<# ... #>`)

*   **Задача:** Корректно форматировать JS/TS код внутри инструкций.
*   **Логика:**
    1.  Для токенов типа `code`, их `content` передается в `prettier.format()` с конфигурацией для `babel` или `typescript`.
    2.  Оригинальные открывающие и закрывающие теги (`<#`, `#>`) сохраняются и обрамляют отформатированный контент.

#### 3.1.3. Обработка Структурных Тегов и Директив

*   **Задача:** Сохранять блоки, слоты и директивы, применяя правила из `MUST_HAVE.md`.
*   **Логика:**
    1.  **Директивы (`<#@ ... #>`):** Не переупорядочиваются. Форматировщик сохраняет их в исходных позициях и с исходной индентацией.
    2.  **Блоки и Слоты (`<# block ... #>`):**
        *   Конструкция `<#- block` должна быть нормализована до `<# block`.
        *   Содержимое блока форматируется **без дополнительного отступа**, так как финальный отступ определяется местом вызова `content()`.
    3.  **Инструкции (`<# ... #>`):** По возможности должны размещаться на отдельных строках, если они еще не находятся в начале строки.

### 3.2. Настройка Prettier

В `server/src/server.ts` необходимо обновить функции `getPrettierOpts` и `getCodePrettierOpts`:

*   **Для текста шаблона (`getTextPrettierOpts`):**
    *   `parser`: Определяется по `defaultLang` (`html`, `markdown`, `babel`).
    *   `printWidth`: 120 (или из настроек).
    *   **`htmlWhitespaceSensitivity`: 'css'** — **Обязательно для HTML**, чтобы предотвратить схлопывание пробелов и переносов строк.
*   **Для кода инструкций (`getCodePrettierOpts`):**
    *   `parser`: 'babel' или 'typescript'.
    *   `printWidth`: 120.
    *   `semi`: true.
    *   `singleQuote`: true.

## 4. Спецификация: Исправление Навигации

### 4.1. Логика `onDefinition`

*   **Задача:** Исправить переход по `content('name')`, чтобы он вел к правильному блоку.
*   **Логика:**
    1.  При нахождении курсора на имени блока внутри `content('block_name')` извлечь `block_name`.
    2.  Выполнить **прямой поиск** по ключу `block_name` в `ast.blocks` для текущего файла.
    3.  Если не найдено, выполнить поиск в `ast.blocks` родительского шаблона (полученного через `getExtendTargetFrom`).
    4.  **НЕ ИСПОЛЬЗОВАТЬ** поиск по всему тексту через `RegExp`.

## 5. Спецификация: Исправление Диагностики

### 5.1. Логика Подсказок по Trimming

*   **Задача:** Убрать некорректные подсказки для структурных тегов.
*   **Логика:**
    1.  В `server/src/server.ts`, в функции `computeDiagnostics`, перед созданием диагностики для trimming (`Consider '<#-'`), добавить проверку.
    2.  Проанализировать текст после `<#` (`tail` в текущем коде). Если он начинается со `block`, `slot` или `end`, пропустить создание подсказки.

## 6. Спецификация: Обновление Стратегии Тестирования

*   **Задача:** Создать надежные тесты, которые будут ловить регрессии форматирования.
*   **Требования:**
    1.  Все тесты на форматирование **ДОЛЖНЫ** использовать `expect(formattedText).toBe(expectedText)` для проверки **полного и точного** совпадения результата.
    2.  Создать новые файлы E2E тестов в `server/__tests__/` для каждого проблемного кейса:
        *   `formatter-panel-bug.test.js`: Для примера с удалением блоков.
        *   `formatter-html-bug.test.js`: Для примера со схлопыванием HTML.
        *   `formatter-dotenv-bug.test.js`: Для примера с `dotenv` файлом.
    3.  Тесты должны содержать исходный текст и эталонный (правильно отформатированный) текст.

## 7. План Обновления Документации

*   **BUGS.md:** Обновить статусы исправленных багов на `[x]`. Добавить новые баги, выявленные в ходе анализа.
*   **MUST_HAVE.md:** Обновить статусы выполненных требований. Уточнить формулировки для правил форматирования.



## **Задача 1: Рефакторинг Форматировщика**

**Цель:** Заменить текущий нестабильный алгоритм форматирования на новый, который гарантированно сохраняет структуру документа, корректно использует Prettier и исправляет все связанные с форматированием баги.

---

### **Детальный План Выполнения**

#### **Этап 1: Подготовка и Тестирование (Test-Driven Development)**

Прежде чем вносить изменения в код, необходимо создать тесты, которые воспроизводят текущие ошибки. Это позволит нам точно определить, когда проблема будет решена.

1.  **Создать E2E Тесты для Багов:**
    *   В директории `server/__tests__/` создать следующие файлы:
        *   `formatter-panel-bug.test.js`: Добавить тест, использующий пример с удалением блоков (`panel` alias). В тесте должно быть утверждение `expect(formattedText).toBe(expectedCorrectText)`, где `expectedCorrectText` — это эталонный, правильно отформатированный результат.
        *   `formatter-html-bug.test.js`: Добавить тест с примером HTML-шаблона, который сейчас "схлопывается". Утверждение должно проверять полное совпадение с эталонным отформатированным HTML.
        *   `formatter-dotenv-bug.test.js`: Добавить тест для `.dotenv` файла, который сейчас теряет переносы строк. Утверждение также должно проверять полное совпадение.
2.  **Запустить Тесты и Убедиться в их Провале:**
    *   Выполнить команду `bun run --cwd server test`.
    *   **Ожидаемый результат:** Новые тесты должны упасть, подтверждая наличие багов. Старые тесты могут проходить, что указывает на их недостаточность.

#### **Этап 2: Реализация Нового Алгоритма в `formatterCore.ts`**

Полностью переписать функцию `formatSegments`. Новый алгоритм не должен пытаться синтезировать теги или переставлять элементы на основе их позиций. Он должен работать как потоковый обработчик токенов.

1.  **Основа Алгоритма:**
    *   Функция `formatSegments` должна принимать `items` (которые являются `ast.tokens`) и оригинальный `text`.
    *   Инициализировать пустой массив `result: string[]` для хранения отформатированных частей.
    *   Инициализировать буфер для текстовых сегментов: `let textChunk: string = ''`.

2.  **Создать Функцию `flushTextChunk()`:**
    *   Эта внутренняя функция будет отвечать за форматирование накопленного текстового буфера (`textChunk`).
    *   **Логика:**
        1.  Если `textChunk` пуст, ничего не делать.
        2.  Вызвать `prettier.format(textChunk, prettierTextOptions)`, где `prettierTextOptions` — конфигурация для целевого языка (HTML/Markdown и т.д.).
        3.  Добавить результат в массив `result`.
        4.  Очистить `textChunk`.

3.  **Реализовать Основной Цикл по Токенам:**
    *   Итерировать по каждому `token` из `items` (`ast.tokens`).
    *   Использовать `switch (token.type)` для обработки разных типов токенов:
        *   **case 'text':**
        *   **case 'expression':**
            *   Добавить сырое содержимое токена (`token.start + token.content + token.end`) в `textChunk`. **Не вызывать `flushTextChunk()`** — мы накапливаем текст для контекстного форматирования.
        *   **case 'code':**
            *   Сначала вызвать `flushTextChunk()`, чтобы обработать предыдущий текстовый блок.
            *   Отформатировать `token.content` с помощью `prettier.format(content, prettierCodeOptions)`.
            *   Собрать и добавить в `result` полную конструкцию: `token.start + formattedContent + token.end`.
        *   **case 'directive':**
            *   Вызвать `flushTextChunk()`.
            *   Добавить в `result` полный текст директивы (`token.start + token.content + token.end`) **без изменений**. Добавить перенос строки до и после, если это необходимо для соблюдения правила "директивы на отдельных строках".
        *   **case 'blockStart' | 'slotStart':**
            *   Вызвать `flushTextChunk()`.
            *   Нормализовать тег: заменить `<#- block` на `<# block`.
            *   Добавить нормализованный тег в `result`.
        *   **case 'blockEnd' | 'slotEnd':**
            *   Вызвать `flushTextChunk()`.
            *   Нормализовать и добавить тег в `result`.
        *   **default:**
            *   Вызвать `flushTextChunk()`.
            *   Добавить сырой токен в `result` для сохранения неизвестных конструкций.

4.  **Завершение:**
    *   После цикла обязательно вызвать `flushTextChunk()` еще раз, чтобы обработать последний накопленный текстовый блок.
    *   Соединить массив `result` через `result.join('')` и вернуть.

#### **Этап 3: Настройка Prettier в `server.ts`**

Внести изменения в функции, отвечающие за конфигурацию Prettier.

1.  **Обновить `getPrettierOpts()` (для текста):**
    *   Установить `htmlWhitespaceSensitivity: 'css'`. Это **ключевое изменение** для предотвращения "схлопывания" HTML.
    *   Убедиться, что `parser` правильно определяется на основе `defaultLang`.
2.  **Обновить `getCodePrettierOpts()` (для инструкций):**
    *   Настроить `parser` на `babel` или `typescript`.
    *   Установить `semi: true`, `singleQuote: true` для консистентности кода.

#### **Этап 4: Интеграция и Очистка**

Соединить все части вместе и удалить устаревший код.

1.  **Обновить `onDocumentFormatting` в `server.ts`:**
    *   Убедиться, что в `formatSegments` передается именно `ast.tokens`, а не `ast.main`.
    *   Удалить вызов старой функции `collectAllASTSegments`. Она больше не нужна и является источником ошибок.
2.  **Удалить Устаревший Код:**
    *   Полностью удалить функцию `collectAllASTSegments` из `server.ts`.
    *   Проверить `formatterCore.ts` на наличие других неиспользуемых вспомогательных функций, оставшихся от старого алгоритма, и удалить их.

#### **Этап 5: Финальная Валидация**

1.  **Запустить Все Тесты:**
    *   Выполнить `bun run --cwd server test`.
    *   **Ожидаемый результат:** Все тесты, включая новые E2E, должны успешно пройти.
2.  **Ручное Тестирование:**
    *   Открыть проблемные файлы в VS Code (в режиме отладки расширения).
    *   Применить форматирование и визуально убедиться, что результат соответствует ожиданиям и все баги исправлены.


## **Задачи 2: "Исправление Навигации"**.

**Цель:** Исправить логику перехода к определению (`Go to Definition`), чтобы она корректно работала для блоков (`block`) и слотов (`slot`) в различных сценариях, включая наследование шаблонов, и соответствовала ожиданиям пользователя, описанным в `MUST_HAVE.md` и `BUGS.md`.

---

### **Детальный План Выполнения**

#### **Этап 1: Подготовка Тестовой Среды и Тестов**

Как и в предыдущей задаче, начинаем с тестов, чтобы четко определить критерии успеха. Поскольку тестирование LSP-хендлеров (`onDefinition`) напрямую затруднено, мы создадим "юнит-тесты" для ключевой логики, имитируя входные данные.

1.  **Создать Структуру для Тестирования Навигации:**
    *   В директории `server/__tests__/` создать новый файл: `navigation-definition.test.js`.
    *   В этом файле мы будем тестировать не сам хендлер, а функцию, которую мы из него извлечем.

2.  **Написать Тесты, Воспроизводящие Баги:**
    *   **Тест 1: Некорректный переход при нескольких блоках.**
        *   **Сценарий:** Шаблон содержит два блока: `block 'title'` и `block 'body'`. В тексте есть два вызова: `content('title')` и `content('body')`.
        *   **Действие:** Имитировать запрос "Go to Definition" с курсора на `'body'` в `content('body')`.
        *   **Ожидаемый результат:** Функция должна вернуть позицию объявления `block 'body'`, а не `block 'title'`.
    *   **Тест 2: Переход к родительскому шаблону.**
        *   **Сценарий:** `child.nhtml` расширяет `parent.nhtml`. `parent.nhtml` определяет `block 'header'`. `child.nhtml` переопределяет `block 'header'`.
        *   **Действие:** Имитировать запрос "Go to Definition" с курсора на имени `'header'` в объявлении блока в `child.nhtml`.
        *   **Ожидаемый результат:** Функция должна вернуть позицию объявления `block 'header'` в файле `parent.nhtml`.
    *   **Тест 3: Отсутствие перехода из `content()` (как точка вставки).**
        *   **Сценарий:** Шаблон содержит вызов `#{content()}` (без имени).
        *   **Действие:** Имитировать запрос "Go to Definition" с курсора на слове `content`.
        *   **Ожидаемый результат:** Функция должна вернуть `null`, так как это точка вставки, а не ссылка на определение.

#### **Этап 2: Рефакторинг и Реализация в `server.ts`**

Извлечь и переписать логику из хендлера `connection.onDefinition`.

1.  **Извлечь Логику в Чистую Функцию:**
    *   Создать новую `async` функцию `resolveDefinition(doc, text, offset, ast)` внутри `server.ts`.
    *   Перенести существующую логику из `connection.onDefinition` в эту новую функцию. Хендлер `onDefinition` теперь будет просто вызывать `resolveDefinition` и возвращать ее результат. Это позволит нам тестировать логику изолированно.

2.  **Исправить Основную Логику `resolveDefinition`:**
    *   **Убрать Навигацию по `content()`:**
        *   В самом начале функции добавить проверку: если курсор находится на самом слове `content` (а не на его аргументе-имени), немедленно вернуть `null`.
        *   Пример проверки: `if (around.match(/content\s*\(/)) return null;`

    *   **Реализовать Корректный Поиск Блока по Имени:**
        1.  Сначала определить, находится ли курсор внутри строкового литерала в `content('block_name')`. Для этого можно использовать простой поиск по `RegExp` вокруг курсора.
        2.  Если да, извлечь `block_name`.
        3.  **Поиск:**
            *   Искать `block_name` в `ast.blocks` текущего документа.
            *   Если найден, вычислить и вернуть `Location` для этого объявления.
            *   **Если не найден локально,** проверить, есть ли у файла родитель (`extendsPath`).
            *   Если есть, загрузить и распарсить родительский файл, найти в его `ast.blocks` нужный блок и вернуть `Location`, указывающий на родительский файл.
        4.  **Важно:** Использовать `ast.blocks.get(block_name)` или `ast.blocks[block_name]` для прямого доступа, а не перебор всего текста через `RegExp.exec`, который приводил к ошибке "перехода на первый блок".

    *   **Реализовать Переход к Родителю из Объявления Блока:**
        1.  Определить, находится ли курсор на имени блока в его объявлении (`<# block 'name' : #>`).
        2.  Если да, проверить `extendsPath` текущего файла.
        3.  Если родитель есть, загрузить его, распарсить и найти в его `ast.blocks` блок с таким же именем.
        4.  Если в родителе блок найден, вернуть `Location`, указывающий на объявление в родительском файле.
        5.  Если в родителе блок не найден (или родителя нет), вернуть `Location` текущего объявления.

#### **Этап 3: Интеграция и Валидация**

1.  **Обновить Хендлер `onDefinition`:**
    *   Убедиться, что хендлер теперь вызывает новую функцию `resolveDefinition` и передает ей все необходимые параметры (`doc`, `text`, `offset`, `ast`).

2.  **Запустить Тесты:**
    *   Выполнить команду `bun run --cwd server test navigation-definition.test.js`.
    *   **Ожидаемый результат:** Все новые тесты должны успешно пройти, подтверждая, что:
        *   Переход к определению теперь находит правильный блок, а не всегда первый.
        *   Навигация к родительскому шаблону из дочернего объявления работает.
        *   Навигация из `content()` (без имени) отключена.

3.  **Ручное Тестирование:**
    *   Запустить расширение в режиме отладки.
    *   Открыть тестовые файлы, имитирующие сценарии из тестов.
    *   Использовать `F12` (`Go to Definition`) и убедиться, что все переходы работают корректно.

## **Задачи 3: "Исправление Диагностики"**.

**Цель:** Улучшить систему диагностики, чтобы она предоставляла точные и релевантные предупреждения и ошибки. План включает исправление некорректных подсказок по trimming, а также верификацию вывода ошибок парсера и отсутствующих родительских шаблонов.

---

### **Детальный План Выполнения**

#### **Этап 1: Подготовка Тестовой Среды и Тестов (TDD)**

Создадим тесты, которые будут проверять как исправляемые баги, так и существующую функциональность, чтобы избежать регрессий.

1.  **Создать Новый Тестовый Файл:**
    *   В директории `server/__tests__/` создать файл `diagnostics-rules.test.js`. Этот файл будет содержать тесты для специфических правил диагностики.

2.  **Написать Тесты для Правил Trimming:**
    *   **Тест 1 (Исправление бага): Подсказки для структурных тегов.**
        *   **Сценарий:** Создать несколько строк, содержащих структурные теги (`<# block 'a' : #>`, `<# slot 'b' : #>`, `<# end #>`) с пробелами до или после, которые обычно вызывают подсказку.
        *   **Действие:** Вызвать `computeDiagnostics` для этих строк.
        *   **Ожидаемый результат:** Массив диагностик **не должен** содержать сообщений с текстом `"Consider '<#-'..."` или `"Consider '-#>'..."` для этих строк.

    *   **Тест 2 (Проверка сохранения функциональности): Подсказки для обычного кода.**
        *   **Сценарий:** Создать строку с обычным кодом, например, ` <# if (condition) { #> `.
        *   **Действие:** Вызвать `computeDiagnostics`.
        *   **Ожидаемый результат:** Массив диагностик **должен** содержать соответствующую подсказку о trimming.

3.  **Написать Тесты для Ошибок Парсера и Наследования:**
    *   **Тест 3: Ошибки парсера (незакрытые блоки).**
        *   **Сценарий:** Создать текст шаблона с незакрытым блоком, например, `<# block 'test' : #>`.
        *   **Действие:** Вызвать `computeDiagnostics`.
        *   **Ожидаемый результат:** Массив диагностик должен содержать ошибку (`severity: DiagnosticSeverity.Error`) с сообщением `"Unclosed test"`, подтверждая, что ошибки из `ast.errors` корректно обрабатываются.

    *   **Тест 4: Ошибка отсутствующего родительского шаблона.**
        *   **Сценарий:** Создать текст шаблона с директивой `<#@ extend 'non/existent/template.nhtml' #>`.
        *   **Действие:** Вызвать `computeDiagnostics`.
        *   **Ожидаемый результат:** Массив диагностик должен содержать ошибку с сообщением `"Parent template not found: non/existent/template.nhtml"`.

#### **Этап 2: Реализация Исправлений в `server.ts`**

Внести точечные изменения в функцию `computeDiagnostics` для исправления логики подсказок по trimming.

1.  **Найти Секцию "Trim hints":**
    *   В функции `computeDiagnostics` найти блок `try/catch`, отвечающий за "Trim hints", который начинается примерно так: `const leftRx = /(\n?)([ \t]*)<#/g;`.

2.  **Модифицировать Цикл для Left-Trim (`leftRx`):**
    *   Внутри цикла `while ((ml = leftRx.exec(text)))` добавить проверку сразу после нахождения совпадения.
    *   **Логика:**
        1.  Взять срез текста после найденного `<#`: `const tail = text.slice(ml.index, ml.index + 15);` (15 символов достаточно для определения тега).
        2.  Проверить срез на совпадение с регулярным выражением для структурных тегов: `if (/^<#-?\s*(block|slot|end)\b/.test(tail))`.
        3.  Если совпадение есть, использовать `continue;`, чтобы пропустить итерацию и не создавать диагностику.

3.  **Модифицировать Цикл для Right-Trim (`rightRx`):**
    *   Внутри цикла `while ((mr = rightRx.exec(text)))` уже есть логика поиска открывающего тега: `const openPos = text.lastIndexOf('<#', mr.index);`.
    *   **Логика:**
        1.  После `if (openPos >= 0)` добавить аналогичную проверку.
        2.  Взять срез от `openPos`: `const tail = text.slice(openPos, openPos + 15);`.
        3.  Проверить его по тому же регулярному выражению: `if (/^<#-?\s*(block|slot|end)\b/.test(tail))`.
        4.  Если совпадение есть, использовать `continue;`.

4.  **Проверить Логику Ошибок Парсера и Наследования:**
    *   Убедиться, что блоки кода, отвечающие за обработку `ast.errors` и проверку `getExtendTargetFrom`, не были затронуты и соответствуют спецификации. Изменения здесь не требуются, так как логика уже была реализована ранее — тесты на этапе 1 это подтвердят.

#### **Этап 3: Финальная Валидация**

1.  **Запустить Все Тесты:**
    *   Выполнить команду `bun run --cwd server test`.
    *   **Ожидаемый результат:** Все тесты, включая новый набор из `diagnostics-rules.test.js`, должны успешно пройти. Это подтвердит, что баг с подсказками исправлен, а важные диагностические функции (ошибки парсера, наследования) не сломались.

2.  **Ручное Тестирование:**
    *   Запустить расширение в режиме отладки (F5).
    *   В тестовом `.nhtml` файле написать:
        *   ` <# block 'my-block' : #>` (с пробелом в начале) — убедиться, что **нет** желтого подчеркивания (предупреждения).
        *   ` <# if (true) { #>` (с пробелом в начале) — убедиться, что желтое подчеркивание **есть**.
        *   `<# block 'unclosed' : #>` — убедиться, что появляется красное подчеркивание (ошибка).
        *   `<#@ extend 'bad/path' #>` — убедиться, что появляется красное подчеркивание.

## **Задачи 4: "Обновление Стратегии Тестирования"**.

**Цель:** Создать надежный и строгий набор тестов, который предотвратит будущие регрессии, особенно в модуле форматирования. Новая стратегия должна гарантировать, что результат форматирования **полностью** соответствует ожиданиям, а не частично.

---

### **Детальный План Выполнения**

#### **Этап 1: Формулирование Новых Принципов Тестирования**

Этот этап закладывает основу для всех последующих действий. Необходимо формализовать новые, более строгие правила для написания тестов.

1.  **Принцип №1: Точное Совпадение (`Exact Match Assertion`).**
    *   **Правило:** ВСЕ тесты, проверяющие форматирование, **ДОЛЖНЫ** использовать `expect(result).toBe(expected)`. Использование нестрогих проверок, таких как `toContain()` или `toMatch()`, для валидации конечного результата **ЗАПРЕЩЕНО**, так как они маскируют ошибки в структуре, порядке и полноте документа.
    *   **Обоснование:** Устраняет основную причину, по которой текущие тесты пропускали критические баги (удаление блоков, схлопывание HTML).

2.  **Принцип №2: Приоритет End-to-End (E2E) Тестов для Форматирования.**
    *   **Правило:** Для функциональности, напрямую влияющей на конечный текстовый вывод (форматирование, генерация кода), приоритет отдается E2E тестам. Такие тесты должны принимать на вход полный исходный текст шаблона и сравнивать результат с полным эталонным текстом.
    *   **Обоснование:** E2E тесты проверяют всю цепочку (парсер -> алгоритм -> Prettier -> финальная сборка), что позволяет выявлять сложные интеграционные ошибки.

3.  **Принцип №3: Разработка через Тестирование (Test-Driven Development - TDD).**
    *   **Правило:** Перед исправлением любого бага или реализацией новой функциональности сначала должен быть написан тест, который падает и четко воспроизводит проблему. Задача считается выполненной только тогда, когда этот тест (и все остальные) проходит.
    *   **Обоснование:** Гарантирует, что исправление действительно решает заявленную проблему и не вносит новые ошибки.

4.  **Принцип №4: Понятность и Изолированность Тестов.**
    *   **Правило:** Каждый тест должен проверять один конкретный аспект функциональности. Имена тестов и файлов должны быть самодокументируемыми (например, `it('should preserve newlines in HTML <head> section')` в файле `formatter-html-bugs.test.js`).
    *   **Обоснование:** Упрощает отладку и поддержку тестов в будущем.

#### **Этап 2: Реализация Новых E2E Тестов (согласно Планам Задач 1-3)**

На этом этапе мы реализуем тесты, которые были запланированы для исправления багов.

1.  **Создать E2E Тесты для Багов Форматировщика:**
    *   **Действие:** Реализовать файлы `formatter-panel-bug.test.js`, `formatter-html-bug.test.js` и `formatter-dotenv-bug.test.js`, как описано в плане для Задачи 1.
    *   **Критерий успеха:** Каждый тест содержит переменную `inputText` и `expectedOutputText` и использует утверждение `expect(format(inputText)).toBe(expectedOutputText)`.

2.  **Создать Юнит-тесты для Логики Навигации и Диагностики:**
    *   **Действие:** Реализовать файлы `navigation-definition.test.js` и `diagnostics-rules.test.js`, как описано в планах для Задач 2 и 3.
    *   **Критерий успеха:** Тесты имитируют входные данные для чистых функций и проверяют их возвращаемые значения на точное совпадение.

#### **Этап 3: Рефакторинг Существующих Тестов**

Все существующие тесты должны быть переписаны в соответствии с новыми принципами.

1.  **Аудит и Идентификация Слабых Тестов:**
    *   **Действие:** Проанализировать все файлы в `server/__tests__/`, особенно `formatter-ast.test.js` и `formatter-indent.test.js`.
    *   **Цель:** Найти все использования `toContain` и `toMatch`, которые могут скрыть ошибки.

2.  **Рефакторинг Тестов:**
    *   **Действие:** Для каждого найденного слабого теста:
        1.  Определить, какой **полный** результат должен возвращать тестируемый фрагмент кода.
        2.  Создать эталонную строку `expectedOutput`.
        3.  Заменить `expect(...).toContain(...)` на `expect(...).toBe(expectedOutput)`.
    *   **Пример:**
        *   **Было:** `expect(res).toContain('  Text block should stay  unchanged   ');`
        *   **Станет:**
            ```javascript
            const expected = `Hello 'world'\n<# if (true){ console.log( 1 + 2 ); } #>\n  Text block should stay  unchanged   \n`;
            expect(res).toBe(expected);
            ```

#### **Этап 4: Финальная Валидация и Интеграция в CI**

1.  **Полный Прогон Тестов:**
    *   **Действие:** Выполнить команду `bun run --cwd server test`.
    *   **Критерий успеха:** Вся тестовая сюита (новые и отрефакторенные тесты) должна проходить без ошибок.

2.  **Самопроверка (Code Review):**
    *   **Действие:** Проверить все измененные и новые тестовые файлы на соответствие четырем принципам, изложенным в Этапе 1.

3.  **Планирование Интеграции в CI:**
    *   **Задача (на будущее):** Добавить шаг запуска тестов в рабочий процесс CI (`.github/workflows/ci.yml`).
    *   **Цель:** Автоматически запускать полный набор тестов при каждом push или pull request в `main`, чтобы немедленно выявлять регрессии.

## **Задачи 5: "Обновление Документации"**.

**Цель:** Привести файлы `BUGS.md` и `MUST_HAVE.md` в полное соответствие с реализованными исправлениями и новыми архитектурными решениями. Документация должна стать надежным источником информации, отражающим текущее состояние проекта.

---

### **Детальный План Выполнения**

#### **Этап 1: Подготовка и Сбор Информации**

Перед редактированием документов необходимо четко зафиксировать, какие именно изменения были внесены. Этот список будет служить основой для обновления.

1.  **Аудит Реализованных Изменений:**
    *   **Форматировщик:** Полностью переработан. Теперь он работает с потоком токенов из `ast.tokens`, сохраняет структуру, использует Prettier для текста и кода, и корректно обрабатывает директивы и блоки.
    *   **Парсер:** Улучшен для вывода ошибок (`ast.errors`) и предоставления полного потока токенов (`ast.tokens`).
    *   **Навигация (`onDefinition`):**
        *   Навигация из `content()` (как точка вставки) отключена.
        *   Переход к определению по имени блока в `content('block_name')` исправлен и работает корректно, включая поиск в родительских шаблонах.
        *   Переход к родительскому блоку из дочернего объявления реализован.
    *   **Диагностика:**
        *   Исправлены некорректные подсказки по trimming для структурных тегов (`block`, `slot`, `end`).
        *   Добавлена диагностика ошибок из парсера (`ast.errors`).
        *   Добавлена диагностика для отсутствующих родительских шаблонов.
    *   **Тестирование:** Внедрена новая стратегия со строгими E2E тестами, проверяющими полное совпадение (`.toBe()`). Добавлены новые тесты, воспроизводящие и проверяющие баги.

#### **Этап 2: Обновление `BUGS.md`**

Этот файл должен отражать все известные проблемы — как исправленные, так и те, что еще предстоит решить.

1.  **Добавить Новые Исправленные Баги:**
    *   **Действие:** Добавить в `BUGS.md` новые пункты для критических багов, которые были обнаружены и исправлены.
    *   **Содержимое:**
        ```markdown
        - [x] **Критический баг форматировщика:** Форматировщик полностью удалял или искажал `block` и `slot` декларации. **ИСПРАВЛЕНО:** Алгоритм форматирования полностью переработан для работы с полным потоком AST-токенов.
        - [x] **Критический баг форматировщика:** Форматирование HTML (`.nhtml`) и других текстовых файлов приводило к "схлопыванию" всего контента в одну строку. **ИСПРАВЛЕНО:** Настроены опции Prettier (`htmlWhitespaceSensitivity: 'css'`) и улучшена логика обработки текстовых сегментов.
        - [x] **Навигация:** Переход к определению из `content('name')` всегда вел к первому блоку в файле, а не к блоку с именем `name`. **ИСПРАВЛЕНО:** Реализован корректный поиск по имени блока в AST текущего и родительского шаблонов.
        ```
2.  **Обновить Статус Существующих Багов:**
    *   **Действие:** Пройтись по существующим записям в `BUGS.md` и отметить галочкой `[x]` те, которые были исправлены в ходе последних работ. Например, "Trimming hints suggested for structural tags".
3.  **Добавить Новые Открытые Баги:**
    *   **Действие:** Добавить баг, связанный с подсветкой синтаксиса, который был упомянут, но еще не исправлен.
    *   **Содержимое:**
        ```markdown
        - [ ] **Подсветка синтаксиса:** В некоторых сложных `.nhtml` файлах теряется подсветка после форматирования, особенно для конструкций `#{...}` и смежных тегов. Требуется ревизия TextMate-грамматики.
        ```

#### **Этап 3: Обновление `MUST_HAVE.md`**

Этот файл должен отражать высокоуровневые требования и текущий статус их выполнения.

1.  **Обновить Секцию "Formatter correctness and guardrails":**
    *   **Действие:** Отметить пункты, которые теперь полностью реализованы, и уточнить формулировки.
    *   **Пример:**
        *   Отметить `[x]` для "Strict separation of formatting responsibilities".
        *   Добавить подпункт: `- [x] Форматирование текста (`.nhtml`, `.nmd`) выполняется через Prettier с корректными настройками для сохранения переносов строк.`
        *   Отметить `[x]` для `Expressions inside #{...} and !{...} should be treated as part of the resulting text`.

2.  **Обновить Секцию "Navigation":**
    *   **Действие:** Зафиксировать новые правила навигации.
    *   **Пример:**
        *   Отметить `[x]` для `Navigation on content() should not work...`.
        *   Добавить подпункт: `- [x] Реализован переход к определению родительского блока при клике на имя в дочернем объявлении.`

3.  **Обновить Секцию "Parser and AST":**
    *   **Действие:** Уточнить требование к парсеру.
    *   **Пример:**
        *   Добавить подпункт: `- [x] Парсер возвращает список ошибок (`ast.errors`), которые отображаются в редакторе как диагностика.`

4.  **Обновить Секцию "Diagnostics":**
    *   **Действие:** Отметить выполненные пункты.
    *   **Пример:**
        *   Отметить `[x]` для `An error should be displayed if a template references a non-existent parent template...`.

5.  **Обновить Секцию "Tests and CI":**
    *   **Действие:** Зафиксировать новую стратегию тестирования.
    *   **Пример:**
        *   Добавить подпункт: `- [x] Внедрена стратегия E2E-тестирования форматировщика с проверкой на полное совпадение результата (`.toBe()`).`

#### **Этап 4: Финальная Валидация**

1.  **Проверка Консистентности:**
    *   **Действие:** Прочитать оба обновленных файла (`BUGS.md` и `MUST_HAVE.md`) и убедиться, что информация в них не противоречит друг другу и точно отражает текущее состояние проекта.
2.  **Проверка Читаемости:**
    *   **Действие:** Убедиться, что все новые и измененные пункты написаны ясным и понятным языком.

## **Задаче 6: "Обновление Документации"**.

**Цель:** Синхронизировать `BUGS.md` и `MUST_HAVE.md` с реализованными изменениями. Документация должна точно отражать текущее состояние проекта, зафиксировать принятые решения и служить надежным источником информации для команды.

---

### **Детальный План Выполнения**

#### **Этап 1: Аудит и Подготовка Списка Изменений**

Перед редактированием файлов необходимо составить исчерпывающий список всех значимых изменений, внесенных в ходе выполнения Задач 1-5. Этот список будет служить чек-листом для обновлений.

1.  **Сформировать Сводку Изменений:**
    *   **Форматировщик:**
        *   [✓] Алгоритм полностью заменен на потоковую обработку `ast.tokens`.
        *   [✓] Исправлена проблема удаления блоков и директив.
        *   [✓] Исправлено "схлопывание" HTML с помощью опции `htmlWhitespaceSensitivity: 'css'`.
        *   [✓] `#{...}` теперь обрабатывается как часть текста, а не как отдельный JS-код.
        *   [✓] Директивы выносятся в начало блока/файла.
        *   [✓] `<#- block` нормализуется в `<# block`.
    *   **Парсер:**
        *   [✓] Теперь возвращает `ast.errors` с ошибками структуры (незакрытые/несопоставленные теги).
        *   [✓] Теперь возвращает `ast.tokens` с полным плоским списком токенов.
    *   **Навигация (`onDefinition`):**
        *   [✓] Навигация по `content()` (самому слову) отключена.
        *   [✓] Навигация по имени блока в `content('name')` исправлена (использует AST, ищет в текущем и родительском файлах).
        *   [✓] Добавлена навигация от объявления блока в дочернем файле к родительскому.
    *   **Диагностика (`computeDiagnostics`):**
        *   [✓] Отключены подсказки по trimming для структурных тегов (`block`, `slot`, `end`).
        *   [✓] Добавлено отображение ошибок из `ast.errors`.
        *   [✓] Добавлена ошибка для несуществующих родительских шаблонов в `<#@ extend ... #>`.
    *   **Тестирование:**
        *   [✓] Внедрена стратегия E2E-тестов с проверкой на полное совпадение (`.toBe()`).
        *   [✓] Созданы новые тесты для всех исправленных багов.

#### **Этап 2: Обновление `BUGS.md`**

Этот файл должен стать "живым" журналом проблем, отражая, что было исправлено и что еще предстоит сделать.

1.  **Открыть `BUGS.md` для Редактирования.**

2.  **Добавить Новые Исправленные Баги:**
    *   **Действие:** Добавить в начало файла новые пункты для всех критических багов, которые были исправлены. Использовать формат `[x] <Описание проблемы>. **ИСПРАВЛЕНО:** <Краткое описание решения>.`
    *   **Пример содержимого:**
        ```markdown
        - [x] **Критический баг форматировщика:** Форматирование удаляло или полностью искажало содержимое блоков (`<# block ... #>`). **ИСПРАВЛЕНО:** Алгоритм форматирования переписан для работы с полным потоком AST-токенов (`ast.tokens`), что гарантирует сохранение структуры.
        - [x] **Критический баг форматировщика:** Форматирование HTML (`.nhtml`) приводило к схлопыванию всего контента в одну строку. **ИСПРАВЛЕНО:** Включена опция Prettier `htmlWhitespaceSensitivity: 'css'` и улучшена логика обработки текстовых сегментов.
        - [x] **Навигация:** Переход к определению из `content('name')` всегда вел к первому блоку в файле. **ИСПРАВЛЕНО:** Реализован корректный поиск по имени блока в AST.
        ```

3.  **Обновить Существующие Записи:**
    *   **Действие:** Пройтись по уже существующим пунктам в `BUGS.md`. Если проблема была решена в рамках последних правок, отметить ее как выполненную `[x]`.
    *   **Пример:** `[x] Trimming hints suggested for structural tags...`

4.  **Добавить Новые Обнаруженные Проблемы (если есть):**
    *   **Действие:** Если в ходе работы были выявлены новые, но еще не исправленные проблемы (например, с подсветкой синтаксиса в специфических случаях), добавить их в конец списка с маркером `[ ]`.
    *   **Пример:**
        ```markdown
        - [ ] **Подсветка синтаксиса:** В некоторых `.nhtml` файлах после форматирования теряется подсветка для `#{...}`. Требуется ревизия `template-html.tmLanguage.json`.
        ```

#### **Этап 3: Обновление `MUST_HAVE.md`**

Этот файл должен отражать высокоуровневые архитектурные решения и требования.

1.  **Открыть `MUST_HAVE.md` для Редактирования.**

2.  **Обновить Секцию "Formatter correctness and guardrails":**
    *   **Действие:** Отметить `[x]` пункты, которые теперь полностью реализованы. Уточнить формулировки, чтобы они отражали новую архитектуру.
    *   **Пример обновления:**
        ```markdown
        - [x] Template instructions vs template text MUST be formatted separately.
        - [x] Expressions inside `#{...}` and `!{...}` should be treated as part of the resulting text...
        - [x] Directive lines (`<#@ ... #>`) should be automatically placed at the top of the template or block...
        ```

3.  **Обновить Секцию "Parser and AST":**
    *   **Действие:** Добавить новые подпункты, описывающие возможности парсера.
    *   **Пример:**
        ```markdown
        - [x] The parser should be embedded directly into the extension...
        - [x] **NEW:** The parser MUST return a flat stream of tokens (`ast.tokens`) in the original document order for reliable formatting.
        - [x] **NEW:** The parser MUST return a list of structural errors (`ast.errors`) for diagnostics.
        ```

4.  **Обновить Секции "Navigation" и "Diagnostics":**
    *   **Действие:** Отметить `[x]` выполненные требования и добавить новые, если необходимо.
    *   **Пример:**
        ```markdown
        - [x] Navigation on `content()` should not work...
        - [x] The system should highlight structural errors in the block structure (e.g., unclosed blocks).
        ```

5.  **Добавить Секцию по Тестированию (если отсутствует):**
    *   **Действие:** Создать или обновить секцию "Tests and CI", чтобы зафиксировать новую стратегию.
    *   **Пример:**
        ```markdown
        ### Tests and CI
        - [x] **NEW:** All formatter tests MUST use strict end-to-end validation (`.toBe()`) to prevent regressions.
        - [x] Unit tests for formatter guardrails and AST helpers.
        ```

#### **Этап 4: Финальная Проверка**

1.  **Вычитка и Корректура:**
    *   **Действие:** Внимательно прочитать оба обновленных файла.
    *   **Цель:** Убедиться в отсутствии опечаток, грамматических ошибок и двусмысленности. Информация должна быть точной и легкой для понимания.
2.  **Сохранение Изменений:**
    *   **Действие:** Сохранить оба файла.
